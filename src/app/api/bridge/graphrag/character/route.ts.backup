/**
 * Character GraphRAG Integration API
 * 
 * Bridges character knowledge graphs with the backend GraphRAG system
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { characterLockService } from '@/lib/ai/characterLock'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

// Debug environment variables during build
console.log('BUILD DEBUG - SUPABASE_URL:', process.env.NEXT_PUBLIC_SUPABASE_URL?.substring(0, 30) + '...')
console.log('BUILD DEBUG - URL length:', process.env.NEXT_PUBLIC_SUPABASE_URL?.length)

const BACKEND_ORIGIN = process.env.BACKEND_ORIGIN || 'http://localhost:3010'

// Initialize character in knowledge graph
export async function POST(req: NextRequest) {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    
    const body = await req.json()
    const { action, characterId, profile, updates, query } = body
    
    if (!action || !characterId) {
      return NextResponse.json({ 
        error: 'Action and character ID are required' 
      }, { status: 400 })
    }
    
    // Get character profile to verify ownership
    const character = await characterLockService.getCharacterProfile(characterId)
    
    if (!character) {
      return NextResponse.json({ error: 'Character not found' }, { status: 404 })
    }
    
    // Verify user owns the project
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('id')
      .eq('id', character.projectId)
      .eq('user_id', user.id)
      .single()
    
    if (projectError || !project) {
      return NextResponse.json({ error: 'Unauthorized access to character' }, { status: 403 })
    }
    
    // Build backend request
    const cookieToken = req.cookies.get('backend_jwt')?.value
    const authHeader = req.headers.get('authorization') || 
                      (cookieToken ? `Bearer ${cookieToken}` : 
                      (process.env.BACKEND_SERVICE_JWT ? `Bearer ${process.env.BACKEND_SERVICE_JWT}` : ''))
    
    let endpoint = ''
    let requestBody: any = {}
    
    switch (action) {
      case 'initialize':
        endpoint = '/api/graphrag/character/initialize'
        requestBody = { characterId, profile: profile || character }
        break
        
      case 'update':
        endpoint = '/api/graphrag/character/update'
        requestBody = { characterId, updates }
        break
        
      case 'search':
        endpoint = '/api/graphrag/character/search'
        requestBody = { characterId, query }
        break
        
      case 'relationships':
        endpoint = '/api/graphrag/character/relationships'
        requestBody = { characterId }
        break
        
      case 'story-elements':
        endpoint = '/api/graphrag/character/story-elements'
        requestBody = { characterId }
        break
        
      default:
        return NextResponse.json({ error: 'Invalid action' }, { status: 400 })
    }
    
    // Forward to backend GraphRAG service
    const response = await fetch(`${BACKEND_ORIGIN}${endpoint}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(authHeader ? { Authorization: authHeader } : {}),
      },
      body: JSON.stringify(requestBody),
    })
    
    const payload = await response.json().catch(() => ({}))
    
    // Update character knowledge graph if successful
    if (response.ok && (action === 'initialize' || action === 'update')) {
      try {
        await characterLockService.updateCharacterKnowledgeGraph(characterId, payload)
      } catch (error) {
        console.warn('Failed to update local character knowledge graph:', error)
      }
    }
    
    return NextResponse.json(payload, { status: response.status })
    
  } catch (error) {
    console.error('Character GraphRAG API error:', error)
    return NextResponse.json({ 
      error: 'Character GraphRAG operation failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

// Get character knowledge graph status
export async function GET(req: NextRequest) {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    
    let searchParams: URLSearchParams
    try {
      const requestUrl = req.url || `http://localhost:3000${req.nextUrl?.pathname || '/api/bridge/graphrag/character'}`
      searchParams = new URL(requestUrl).searchParams
    } catch (error) {
      console.warn('Failed to parse request URL, using empty search params')
      searchParams = new URLSearchParams()
    }
    const characterId = searchParams.get('characterId')
    
    if (!characterId) {
      return NextResponse.json({ error: 'Character ID is required' }, { status: 400 })
    }
    
    // Get character profile to verify ownership
    const character = await characterLockService.getCharacterProfile(characterId)
    
    if (!character) {
      return NextResponse.json({ error: 'Character not found' }, { status: 404 })
    }
    
    // Verify user owns the project
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('id')
      .eq('id', character.projectId)
      .eq('user_id', user.id)
      .single()
    
    if (projectError || !project) {
      return NextResponse.json({ error: 'Unauthorized access to character' }, { status: 403 })
    }
    
    // Get character relationships and story elements from database
    const [relationshipsResult, elementsResult] = await Promise.allSettled([
      supabase
        .from('character_relationships')
        .select(`
          *,
          target_character:character_profiles!target_character_id(id, name)
        `)
        .eq('character_id', characterId),
      supabase
        .from('character_story_elements')
        .select('*')
        .eq('character_id', characterId)
    ])
    
    const relationships = relationshipsResult.status === 'fulfilled' 
      ? relationshipsResult.value.data || []
      : []
    
    const storyElements = elementsResult.status === 'fulfilled'
      ? elementsResult.value.data || []
      : []
    
    return NextResponse.json({
      success: true,
      character,
      relationships,
      storyElements,
      knowledgeGraph: {
        characterId,
        relationshipCount: relationships.length,
        storyElementCount: storyElements.length,
        lastUpdated: character.updatedAt
      }
    })
    
  } catch (error) {
    console.error('Error fetching character knowledge graph:', error)
    return NextResponse.json({ 
      error: 'Failed to fetch character knowledge graph',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}